var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch({preset:'score',cache:!0,doc:{id:'id',field:['title','description','content'],store:['href','title','description']}}),c=[{id:0,href:"/blog/kubernetes-authorization/",title:"Kubernetes Authorization",description:"Authorization grants you access permission for resources in the cluster. A Kubernetes cluster will only authorize your requests after authentication.",content:'\u003cp\u003eKubernetes API Server is implemented as a RESTful API service and acts as a front end to its control plane. \u003ca href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm"\u003eREST\u003c/a\u003e is an architecture style developed by \u003ca href="http://www.ics.uci.edu/~fielding/"\u003eRoy Thomas Fielding\u003c/a\u003e. One of the guiding principles of REST is statelessness. Each request from a client must contain all the information required to complete the request, including authentication and authorization. The RESTful API implementation in Kubernetes makes it compatible with existing on-prem or cloud access systems.\u003c/p\u003e\n\u003cp\u003eThe API server denies all requests by default. It only authorizes a request when all parts of the request match a policy. You can configure multiple authorization modes. In such a case, it will evaluate all authorization modes one by one until it finds the first authorizer that approves or denies the request, and it immediately returns the result ignoring the rest of the authorizers.\u003c/p\u003e\n\u003cp\u003eKubernetes supports several authorization modes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRBAC\u003c/li\u003e\n\u003cli\u003eNode\u003c/li\u003e\n\u003cli\u003eABAC\u003c/li\u003e\n\u003cli\u003eWebhook\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id="rbac"\u003eRBAC\u003c/h4\u003e\n\u003cp\u003eRole based access control (RBAC), formalized by \u003ca href="https://csrc.nist.gov/publications/detail/conference-paper/1992/10/13/role-based-access-controls"\u003eDavid Ferraiolo and Rick Kuhn\u003c/a\u003e, has been widely adopted by organizations to grant access to systems based on a person\u0026rsquo;s role within the organization or team.  In Kubernetes, roles have a set of permissions tied to them. The permissions match verbs with resources; for instance,  create, get, update, patch, delete with resources pods, services, nodes, etc. The permissions can have a namespace or cluster-wide scope. The API requests made to \u003ccode\u003e/api/v1/...\u003c/code\u003e or \u003ccode\u003e/apis/\u0026lt;group\u0026gt;/\u0026lt;version\u0026gt;/...\u003c/code\u003e are considered resource requests. Any other requests are \u0026ldquo;non-resource-requests.\u0026rdquo; They use the HTTP method as the lower case verb. For instance, the GET method becomes the get verb.\u003c/p\u003e\n\u003cp\u003eRBAC authorization uses the \u003ccode\u003erbac.authorization.k8s.io\u003c/code\u003e API group to drive authorization decisions, allowing you to configure policies through the Kubernetes API dynamically.\u003c/p\u003e\n\u003cp\u003eThere are no \u0026ldquo;deny\u0026rdquo; rules in RBAC roles as they are purely additive. An excellent way to think about it is that users, groups, or service accounts are denied access to cluster resources by default, and you explicitly grant access to them. A role does not specify a user or group of users; you essentially assign roles to users or groups, thus creating a binding.  In Kubernetes, you define your RBAC permissions using the following objects:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e\u003cstrong\u003eClusterRole\u003c/strong\u003e\u003c/em\u003e or \u003cem\u003e\u003cstrong\u003eRole\u003c/strong\u003e\u003c/em\u003e contains a set of resources and operations that a user or group of users can perform on them. If you want to define a role within a namespace, use the Role object; if you\u0026rsquo;re going to define a role cluster-wide, use a ClusterRole.\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e\u003cstrong\u003eClusterRoleBinding\u003c/strong\u003e\u003c/em\u003e or \u003cem\u003e\u003cstrong\u003eRoleBinding\u003c/strong\u003e\u003c/em\u003e assigns (binds) a ClusterRole or Role to a user or group of users. A ClusterRoleBinding only is used with a ClusterRole. RoleBinding, on the other hand, will work with either ClusterRole or Role.\nClusterRole allows you to control permissions cluster-wide and have several uses. For instance, grant permissions across all namespaces (for example, all pods cluster-wise), within namespaces, or cluster-wide resources, like nodes. In addition, ClusterRole can be used to control access to non-resources API endpoints, such as \u003ccode\u003e/healthz\u003c/code\u003e. See \u003ca href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/"\u003eUsing RBAC Authorization\u003c/a\u003e for various examples.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id="node"\u003eNode\u003c/h4\u003e\n\u003cp\u003eNode authorization mode in Kubernetes authorizes API requests made by kubelets running on nodes. The kubelet is the primary \u0026ldquo;node agent\u0026rdquo; that runs on each node and ensures that the containers are running and healthy.  The node authorizer enables kubelets to perform read, write, and authentication-related operations.\u003c/p\u003e\n\u003ch4 id="abac"\u003eABAC\u003c/h4\u003e\n\u003cp\u003eAttribute-based access control (ABAC) is an access control model that consists of rules based on the attributes of the subject (user or group), attributes of the object (pods, namespace), action (read, write), and environmental conditions (nonResourcePath: \u003ccode\u003e/version\u003c/code\u003e). In addition, ABAC policies express a true/false set that can evaluate many attributes.  Role-based Access Control (RBAC) is a preferred authorization method over the legacy ABAC in Kubernetes. Managing ABAC policies requires one to log into the node to update the file containing ABAC policies. In contrast, administrators can manage RBAC through Kubernetes API.\u003c/p\u003e\n\u003cp\u003eIn the following example, Bob can read pods in the \u0026ldquo;projectCaribou\u0026rdquo; namespace.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e{\n  \u0026quot;apiVersion\u0026quot;: \u0026quot;abac.authorization.kubernetes.io/v1beta1\u0026quot;,\n  \u0026quot;kind\u0026quot;: \u0026quot;Policy\u0026quot;,\n  \u0026quot;spec\u0026quot;:\n    {\n      \u0026quot;user\u0026quot;: \u0026quot;bob\u0026quot;,\n      \u0026quot;namespace\u0026quot;: \u0026quot;projectCaribou\u0026quot;,\n      \u0026quot;resource\u0026quot;: \u0026quot;pods\u0026quot;,\n      \u0026quot;readonly\u0026quot;: true\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="webhook"\u003eWebhook\u003c/h4\u003e\n\u003cp\u003eA webhook is a callback over HTTP. A callback is usually a function passed to another function. The first function calls this function (callback) after it completes.  A more intuitive name for the callback is the \u0026ldquo;call-after\u0026rdquo; function. An application implementing webhooks will usually POST  a message to a URL when certain events occur. For examples, when Webhook mode is active, Kubernetes will query an outside RESTful service to determine user privileges. Here is an example of a request the API Server would POST to the remote service for an authorization decision.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e{\n  \u0026quot;apiVersion\u0026quot;: \u0026quot;authorization.k8s.io/v1beta1\u0026quot;,\n  \u0026quot;kind\u0026quot;: \u0026quot;SubjectAccessReview\u0026quot;,\n  \u0026quot;spec\u0026quot;: {\n    \u0026quot;resourceAttributes\u0026quot;: {\n      \u0026quot;namespace\u0026quot;: \u0026quot;kittensandponies\u0026quot;,\n      \u0026quot;verb\u0026quot;: \u0026quot;get\u0026quot;,\n      \u0026quot;group\u0026quot;: \u0026quot;unicorn.example.org\u0026quot;,\n      \u0026quot;resource\u0026quot;: \u0026quot;pods\u0026quot;\n    },\n    \u0026quot;user\u0026quot;: \u0026quot;jane\u0026quot;,\n    \u0026quot;group\u0026quot;: [\n      \u0026quot;group1\u0026quot;,\n      \u0026quot;group2\u0026quot;\n    ]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe remote service would respond and fill the \u0026lsquo;status\u0026rsquo; field of the request to allow or disallow the request.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-yaml"\u003e{\n  \u0026quot;apiVersion\u0026quot;: \u0026quot;authorization.k8s.io/v1beta1\u0026quot;,\n  \u0026quot;kind\u0026quot;: \u0026quot;SubjectAccessReview\u0026quot;,\n  \u0026quot;status\u0026quot;: {\n    \u0026quot;allowed\u0026quot;: false,\n    \u0026quot;denied\u0026quot;: true,\n    \u0026quot;reason\u0026quot;: \u0026quot;user does not have read access to the namespace\u0026quot;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id="key-takeaways"\u003eKey Takeaways\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eOne of the guiding principles of REST is statelessness. Each request from a client must contain all the information required to complete the request, including authentication and authorization.\u003c/li\u003e\n\u003cli\u003eThe API server denies all requests by default. It only authorizes a request when all parts of the request match a policy.\u003c/li\u003e\n\u003cli\u003eKubernetes will evaluate all configured authorization modes and return immediately as soon as it finds one that approves or denies the request and ignores the rest of the authorizers.\u003c/li\u003e\n\u003cli\u003eThere are no \u0026ldquo;deny\u0026rdquo; rules in RBAC roles as they are purely additive.  The users, groups, or service accounts are denied access to cluster resources by default, and you explicitly grant access to them.\u003c/li\u003e\n\u003cli\u003eA role does not specify a user or group of users; you essentially assign roles to users or groups, thus creating a binding.\u003c/li\u003e\n\u003cli\u003eNode authorization mode in Kubernetes authorizes API requests made by kubelets running on nodes.\u003c/li\u003e\n\u003cli\u003eAttribute-based access control (ABAC) is an access control model that consists of rules based on the attributes of the subject (user or group), attributes of the object (pods, namespace), action (read, write), and environmental conditions (nonResourcePath: \u0026ldquo;/version\u0026rdquo;).\u003c/li\u003e\n\u003cli\u003eManaging ABAC policies requires one to log into the node to update the file containing ABAC policies. In contrast, administrators can manage RBAC through Kubernetes API.\u003c/li\u003e\n\u003cli\u003eA webhook is a callback over HTTP. A callback is usually a function passed to another function. The first function calls this function (callback) after it completes; sometimes, it is called a \u0026ldquo;call-after\u0026rdquo; function.\u003c/li\u003e\n\u003cli\u003eWhen Webhook mode is active, Kubernetes will query an outside RESTful service to determine user privileges.\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:1,href:"/blog/kubernetes-authentication/",title:"Kubernetes Authentication",description:"Authentication in Kubernetes is about verifying the identity of users and services.",content:'\u003cp\u003eThis post will discuss authentication methods for two types of accounts that access the Kubernetes cluster: users and machines. While cluster administrators and application developers require access to the cluster to manage and deploy applications respectively, machines, processes, and applications also need access to the cluster, which they obtain through the service accounts.\u003c/p\u003e\n\u003cfigure class="wide"\u003e\n  \u003cimg class="img-fluid lazyload blur-up" data-sizes="auto" src="/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_20x0_resize_box_2.png" data-srcset="https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_900x0_resize_box_2.png 900w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_800x0_resize_box_2.png 800w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_700x0_resize_box_2.png 700w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_600x0_resize_box_2.png 600w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_500x0_resize_box_2.png 500w" width="1280" height="720" alt="Kubernetes Authentication"\u003e\n  \u003cnoscript\u003e\u003cimg class="img-fluid" sizes="100vw" srcset="https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_900x0_resize_box_2.png 900w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_800x0_resize_box_2.png 800w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_700x0_resize_box_2.png 700w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_600x0_resize_box_2.png 600w,https://foreops.com/blog/kubernetes-authentication/kubernetes-authentication_hue38ed8ce16d10c8c4e617f6df2de1956_70091_500x0_resize_box_2.png 500w" src="/blog/kubernetes-authentication/kubernetes-authentication.png" width="1280" height="720" alt="Kubernetes Authentication"\u003e\u003c/noscript\u003e\n  \u003cfigcaption class="figure-caption"\u003eKubernetes Authentication\u003c/figcaption\u003e\n\u003c/figure\u003e\n\n\u003ch3 id="user-authentication"\u003eUser Authentication\u003c/h3\u003e\n\u003cp\u003eKubernetes does not have objects which represent user accounts. Users do not log in, and there are no sessions or timeouts. Every request made to the API server is unique, and it contains everything that the API server requires to authenticate/authorize the request. There are many different authentication mechanisms to choose from based on suitability to specific types of implementation.\u003c/p\u003e\n\u003cp\u003eOne of the simplest methods is to use a static token file in CSV format with three required columns: token, user name, user uid, and an optional column for group names. The API server reads bearer tokens from this file which is specified as a command-line option. Updates to the file require access to the node running the API server. Every time the file changes, you have to restart the API server. However, this is not a recommended authentication method as the tokens can last forever.\u003c/p\u003e\n\u003cp\u003eUsers can also authenticate by presenting a certificate signed by the cluster\u0026rsquo;s certificate authority (CA). The user submits the certificate in the form of a Certificate Header or through the kubectl command. The API server reads the username (CN=devuser) and group name (O=engineering) from the \u0026lsquo;subject\u0026rsquo; line of the certificate. When using this method, the administrators are responsible for generating, revoking, and expiry of certificates.\u003c/p\u003e\n\u003cp\u003eMost of the time, OIDC (OpenID Connect) is used in a production or cloud environment. Users authenticate with their OIDC platform to get tokens. The administrators configure the API server to accept these tokens that contain identity information. It Is also important to note that Kubernetes does not connect to a user directory.\u003c/p\u003e\n\u003cp\u003eTwo more methods are available to use custom identity providers, authenticating proxy or authentication webhook. Authentication proxy used to integrate with LDAP, SAML, Kerberos, alternate x509 schemes, etc. HTTP headers specify a username, group, and any extra information about the user. On the API server, these headers are mapped to the required API server switches.\u003c/p\u003e\n\u003cp\u003eWebhook authentication allows users to generate tokens through the external service. The users use these tokens when authenticating with the API server. When a client starts to authenticate using a bearer token, the authentication webhook POSTs a JSON-serialized TokenReview object containing the token to the remote service. The remote service indicates success by updating a status field in the request. Usernames derived from various supported authentication identity providers must be unique cluster-wide.\u003c/p\u003e\n\u003ch3 id="machine-authentication"\u003eMachine Authentication\u003c/h3\u003e\n\u003cp\u003eThe Service Account controller manages service accounts inside namespaces. It creates a service account named \u0026ldquo;default\u0026rdquo; in all active namespaces. When a pod\u0026rsquo;s manifest does not specify a service account,  it will use the \u0026ldquo;default\u0026rdquo; service account in its namespace. Service accounts that do not belong to the kube-system namespace have no permissions. Applications access the API server using the service account specified in their pod. An excellent example of such an application is a Kubernetes dashboard that exists in a pod. It will use the service account to talk to the API server. Service accounts use credentials from secrets mounted into pods. Only one service account is per pod is used. Any required roles can be granted to service accounts as needed. Application-specific service accounts should be created and given permissions as needed.\u003c/p\u003e\n\u003cp\u003eWhen the API server creates a service account, it generates a token and stores it in a secret object. The API server then links this to the newly created service account. The token in secret is an authentication bearer token used to communicate with the API server. On pods creation, the secret is made available to the pod as a volume.\u003c/p\u003e\n\u003ch3 id="key-takeaways"\u003eKey Takeaways\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAuthentication in Kubernetes is about verifying the identity of users (humans) and services (machines, processes, or applications).\nKubernetes does not have objects which represent user accounts. Users do not log in, and there are no sessions or timeouts.\u003c/li\u003e\n\u003cli\u003eYou do not connect Kubernetes to a user directory. Kubernetes supports several authentication mechanisms out of the box and provides support for custom authentication schemes.\u003c/li\u003e\n\u003cli\u003eUsernames derived from various supported authentication identity providers must be unique cluster-wide.\u003c/li\u003e\n\u003cli\u003eA service account named \u0026ldquo;default\u0026rdquo; exists in all active namespaces.\u003c/li\u003e\n\u003cli\u003eService accounts that do not belong to the kube-system namespace have no permissions.\u003c/li\u003e\n\u003cli\u003eService accounts use credentials from secrets mounted into pods. Each pod can use one service account only.\u003c/li\u003e\n\u003cli\u003eWhen you create pods, the secret in the service account is made available as a volume.\u003c/li\u003e\n\u003c/ul\u003e\n'},{id:2,href:"/blog/",title:"Blog",description:"The foreops blog.",content:""}];b.add(c),userinput.addEventListener('input',e,!0),suggestions.addEventListener('click',f,!0);function e(){var g=this.value,e=b.search(g,5),f=suggestions.childNodes,h=0,i=e.length,c;for(suggestions.classList.remove('d-none'),e.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.href,t.textContent=b.title,d.textContent=b.description,suggestions.appendChild(c)});f.length>i;)suggestions.removeChild(f[h])}function f(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()